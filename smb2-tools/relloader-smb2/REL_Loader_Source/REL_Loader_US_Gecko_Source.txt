# 80065184 - Address to hook for this code

# Restore the overwritten instruction
stw r30,0x8(sp)

# Initialize static values used for addresses
lis r31,0x8000
lis r30,0x8002
lis r29,0x8001

li r28,0 # Used to check if a REL file is loaded or not

# Check if a memory card is present
# To avoid an infinite loop, only check for a memory card a set amount of times
lis r26,0x000f
ori r26,r26,0x4240 # Check 1,000,000 times

checkForMemoryCardLoop:
ori r3,r30,0x611c # CARDProbeEx
mtctr r3
li r3,0 # Memory card slot A
li r4,0 # Pointer to the memory size (not needed, so NULL)
li r5,0 # Pointer to the sector size (not needed, so NULL)
bctrl
cmpwi r3,-1 # CARD_RESULT_BUSY
bne- exitCheckForMemoryCardLoop

# Exit if the limit has been reached
subic. r26,r26,1
bgt+ checkForMemoryCardLoop

exitCheckForMemoryCardLoop:
cmpwi r3,0 # Check if something went wrong
bne- exit

# Back up the current Arena Low
lwz r27,-0x7f50(r13) # Arena Low

# Allocate memory for the CARDMount work area, CardFileInfo, and the initial 0x200 bytes for reading from the memory card
ori r3,r28,0xa220
bl allocateFromArenaLow

# Backup the returned address to be used for later
mr r26,r3

# Mount the Memory Card
ori r3,r30,0x67b0 # CARDMountAsync
mtctr r3
li r3,0 # Memory Card Slot A
addi r4,r26,0x220 # Pointer to the Work Area
li r5,0 # Detach Callback function (Want to avoid using, so NULL)
li r6,0 # Attach Callback function (Want to avoid using, so NULL)
bctrl
bl finishAsyncFunction
cmpwi r3,0 # Check if something went wrong
bne- freeMemory

# Open the file
ori r3,r30,0x74fc # CARDOpen
mtctr r3
li r3,0 # Memory Card Slot A
ori r4,r31,0x44c0 # File Name
addi r5,r26,0 # Pointer to CardFileInfo
bctrl
cmpwi r3,0 # Check if something went wrong
bne- unmountCard

# Read from the Card
ori r3,r30,0x7cb4 # CARDReadAsync
mtctr r3
addi r3,r26,0 # Pointer to CardFileInfo
addi r4,r26,0x20 # Pointer to the File Buffer
li r5,0x200 # Amount of bytes to read
li r6,0x2000 # Offset in the file to start reading from
li r7,0 # Read Callback function (Want to avoid using, so NULL)
bctrl
bl finishAsyncFunction
cmpwi r3,0 # Check if something went wrong
bne- closeCard

# Get the file size and adjust it to be in multiples of 0x200 bytes
lwz r25,0x60(r26) # File Size
addi r25,r25,511
rlwinm r25,r25,0,0,22

# Allocate memory based on the adjusted file size
mr r3,r25
bl allocateFromArenaLow

# Backup the returned address to be used for later
mr r24,r3

# Read the REL Area of the file
ori r3,r30,0x7cb4 # CARDReadAsync
mtctr r3
addi r3,r26,0 # Pointer to CardFileInfo
mr r4,r24 # Pointer to the File Buffer
mr r5,r25 # Adjusted File Size
li r6,0x2200 # Offset in the file to start reading from
li r7,0 # Read Callback Function (Want to avoid using, so NULL)
bctrl
bl finishAsyncFunction
cmpwi r3,0 # Check if something went wrong
bne- closeCard

# Get the BSS Area size and allocate memory for it
lwz r3,0x20(r24)
bl allocateFromArenaLow

# Backup the returned address to be used for later
mr r23,r3

# Link the functions in the REL
ori r3,r29,0x730 # OSLink
mtctr r3
mr r3,r24 # Pointer to the Module
mr r4,r23 # Pointer to the BSS Area
bctrl
cmpwi r3,1 # Check if something went wrong
bne- callOSUnlink

# Store the BSS Area and the Module
stw r26,0x452C(r31) # Pointer to the CARDMount work area and other additional memory used
stw r23,0x4530(r31) # Pointer to the BSS Area
stw r24,0x4534(r31) # Pointer to the Module

# Get the REL Prolog Pointer
lwz r28,0x34(r24)

# Done, so close and unmount the card
b closeCard

allocateFromArenaLow:
mflr r14
ori r4,r31,0xd5a8 # OSAllocFromArenaLow
mtctr r4
mr r15,r3 # Size
addi r3,r3,31
rlwinm r3,r3,0,0,26 # Amount to allocate, rounded up to multiple of 32 bytes
li r4,32 # Alignment
bctrl

# Clear the allocated memory
ori r4,r31,0x33a8 # memset
mtctr r4
mr r16,r3 # Dest
li r4,0
mr r5,r15 # Size
bctrl

# Flush the allocated memory
ori r3,r31,0xd8cc # DCFlushRange
mtctr r3
mr r3,r16 # Dest
mr r4,r15 # Size
bctrl
mr r3,r16 # Dest
mtlr r14
blr

finishAsyncFunction:
cmpwi r3,0 # Check if something went wrong
bnelr-
mflr r14

finishAsyncFunctionLoop:
ori r3,r30,0x33e4 # CARDGetResultCode
mtctr r3
li r3,0 # Memory Card Slot A
bctrl
cmpwi r3,-1 # CARD_RESULT_BUSY
beq+ finishAsyncFunctionLoop
mtlr r14
blr

CARDClose:
mflr r0
stw r0,0x4(sp)
stwu sp,-0x18(sp)
stw r31,0x14(sp)
mr r31,r3

ori r3,r30,0x32c8 # __CARDGetControlBlock
mtctr r3
addi r4,sp,0xc
lwz r3,0(r31)
bctrl

cmpwi r3,0
bge- noProblemsFound
b exitCloseCard

noProblemsFound:
ori r3,r30,0x3380 # __CARDPutControlBlock
mtctr r3
li r0,-1
stw r0,0(r31)
li r4,0
lwz r3,0xc(sp)
bctrl

exitCloseCard:
lwz r0,0x1c(sp)
lwz r31,0x14(sp)
addi sp,sp,0x18
mtlr r0
blr

callOSUnlink:
ori r3,r29,0xb8c # OSUnlink
mtctr r3
mr r3,r24 # Pointer to the Module
bctrl

closeCard:
addi r3,r26,0 # Pointer to CardFileInfo
bl CARDClose

unmountCard:
ori r3,r30,0x69ec # CARDUnmount
mtctr r3
li r3,0 # Memory Card Slot A
bctrl

# Free the remaining memory if the load was not successful
freeMemory:
cmpwi r28,0
bne+ runRelProlog
stw r27,-0x7f50(r13) # Arena Low
b exit

# Run the REL Prolog if the load was successful
runRelProlog:
mtctr r28
bctrl

exit:
